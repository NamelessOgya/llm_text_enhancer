ご提示いただいた4つのパターン（TextGrad型、遺伝的アルゴリズム型、Trajectory型、事例選択型）について、**数値評価のみが得られるメルマガ件名生成タスク**を前提とした実装仕様書を作成しました。

これらはすべてモデルの重み更新（学習）を行わず、API経由のプロンプトエンジニアリングとロジックのみで実装可能です。

---

# メルマガ件名最適化システム 実装仕様書群

## 前提条件
*   **タスク:** メルマガの件名生成（入力：本文またはトピック / 出力：件名リスト）
*   **サイクル:** 1バッチあたり10個の件名を生成 $\rightarrow$ ユーザーが数値スコア（0-100等）で評価 $\rightarrow$ 次のバッチを生成
*   **制約:** モデルのファインチューニングは行わない（In-context Learningのみ）。

---

## 1. TextGrad型（擬似勾配による修正）

本来は言語フィードバックが必要ですが、数値スコアをトリガーにしてLLMに「改善点（擬似勾配）」を推論させ、インスタンスを修正するアプローチです。

### 1.1 処理フロー
1.  **Forward:** LLMが件名案を10個生成する。
2.  **Loss:** ユーザーが各件名にスコアを付与する。
3.  **Backward (Gradient Generation):**
    *   スコアが閾値未満の件名に対し、LLMに「この件名が低スコア（例: 30点）だった理由」を推測させる。
    *   プロンプト例: `件名: "{subject}" はスコア30点でした。なぜ評価が低かったのか、改善のための具体的な修正指示（Textual Gradient）を記述してください。`
4.  **Optimizer Step:**
    *   生成された「修正指示」と元の件名をLLMに入力し、修正版を生成させて次回の候補とする。

### 1.2 プロンプト構成
*   **Backward用:** `変数（件名）` + `評価（数値）` $\rightarrow$ 出力：`批判・修正指示`
*   **Update用:** `元の件名` + `修正指示` $\rightarrow$ 出力：`新しい件名`

### 1.3 特徴
*   **メリット:** 個別の件名の質を深く磨き上げることができます。Self-Refineのように、自身の出力に対するフィードバックループを回すことで品質を高めます。
*   **注意点:** 数値から理由を推測するため、LLMの推測精度に依存します。

---

## 2. 遺伝的アルゴリズム型（選択と変異）

進化計算の考え方を適用し、高スコアの件名を「親」として、言い換えや一部変更（変異）を行って次世代を生成します。

### 2.1 処理フロー
1.  **Initialization:** 初期プロンプトで10個生成する。
2.  **Evaluation:** ユーザーがスコアを付与。
3.  **Selection (選択):** スコア上位 $k$ 個（例: 3個）を「親個体」として選定し、残りは破棄する。
4.  **Mutation (変異):**
    *   選ばれた「親」に対し、変異プロンプトを用いてバリエーションを生成し、合計10個になるまで増やす。
    *   変異の種類（ランダムに適用）:
        *   *Paraphrase:* 意味を変えずに言い換える。
        *   *Expand/Shorten:* 具体性を足す、または短くする。
        *   *Tone Change:* 「緊急性を煽る」「親しみやすくする」などトーンを変える。
5.  **Next Generation:** 生成された変異体を次の評価対象とする。

### 2.2 プロンプト構成（変異用）
```text
以下のメルマガ件名は高評価を得ました。
元: "{parent_subject}"
指示: この件名の訴求点を維持しつつ、表現を{mutation_type}して、新しい件名を3つ作成してください。
```

### 2.3 特徴
*   **メリット:** 「なぜ良かったか」の理由が不明でも、結果的に良かったものを生き残らせるため、数値評価との相性が非常に良いです。Promptbreederのように、変異指示自体を進化させることも可能です。

---

## 3. Trajectory型 (OPRO)

過去の試行錯誤の履歴（軌跡）をコンテキストとして与え、LLM自身に「スコアが高くなる法則」を見つけ出させる手法です。

### 3.1 処理フロー
1.  **History Management:** `(件名, スコア)` のペアを履歴として保存する。
2.  **Sort:** 履歴をスコアの昇順（低い $\rightarrow$ 高い）に並べ替える。
3.  **Meta-Prompt Construction:**
    *   プロンプトに「過去の生成物とスコアのリスト」を含める。
    *   「以下の履歴から、高スコアを取る傾向を分析し、さらに高いスコア（100点）を取れる新しい件名を生成せよ」と指示する。
4.  **Generation:** 次の10個を生成する。
5.  **Accumulation:** 新しい結果を履歴に追加し、コンテキスト長に合わせて古い/低いスコアのものを除外する。

### 3.2 プロンプト構成
```text
あなたは最適化AIです。過去のメルマガ件名と評価スコアの履歴は以下の通りです。
[低スコア例] -> ... -> [高スコア例]
この傾向（Trajectory）を分析し、より高い評価を得られる新しい件名を10個生成してください。
```

### 3.3 特徴
*   **メリット:** 実装がシンプルで、最適化のプロセス自体をLLMに委ねることができます。数値回帰問題などでも有効性が示されています。

---

## 4. 事例選択型 (DSPy / BootstrapFewShot)

プロンプト内の「Few-shot（成功事例）」を最適化する手法です。高スコアの件名のみを厳選して「見本」として提示します。
ロジックごとに保存する必要がある一時ファイルは`result/evolution_method/tmp`に保存すること

### 4.1 処理フロー
1.  **Candidate Collection:** 生成した件名とそのスコアを蓄積する。
2.  **Demonstration Selection (Bootstrapping):**
    *   一定の基準（例: 上位10%や80点以上）を満たす件名を「成功事例（Demonstration）」候補とする。
    *   （オプション）DSPyのロジックに従い、多様性を確保するために、類似しすぎた事例は除外するか、ランダムに組み合わせを試行する。
3.  **Prompt Construction:**
    *   選抜された成功事例 $k$ 個を、Few-shotの例示としてプロンプトに埋め込む。
    *   ※Trajectory型とは異なり、スコアの数値自体はプロンプトに含めず、「これらは良い例である」として提示する。
4.  **Generation:** 成功事例に倣って新しい件名を生成する。

### 4.2 プロンプト構成(メルマガ件名を例に)
タスク: 魅力的なメルマガ件名を生成すること。
---
良い件名の例:
- {success_example_1}
- {success_example_2}
- {success_example_3}
---
上記のようなスタイルで、今回の内容に対する件名を10個生成してください。
4.3 特徴
• メリット: 「良い例」を直接見せることで、出力の安定性が高まります。DSPyのコンパイラが自動で行う「教師データからの良質なFew-shot抽出」を手動（または簡易スクリプト）で再現する形になります。